#include<bits/stdc++.h>
using namespace std;

const long long MOD = 1000000007;
long long dp[1000][6];

int main()
{
	int n;
	cin >> n;
	memset(dp, 0, sizeof(dp));
	// 注：以下所有状态都是满足0在1之前，2在3之前的前提的
	dp[1][0] = 1; // 长度为1的时候只有状态1是1，其他状态都是0
	for(int i = 2; i <= n; i++) { // 长度为i,注意这里的长度加1就是往前面状态的后面加一个数字，不是能插入任意地方的
		// 状态0：只含有2，这么设计是因为第一个数字只能为2
		dp[i][0] = 1;
		
		// 状态1：只包含数字2和0（都得有）
		// 1. 原状态后面可以添0或者2
		// 2. 状态0后只能添一个0,构成包含这两个数字的情况
		dp[i][1] = (dp[i - 1][1] * 2 + dp[i - 1][0]) % MOD;
		
		// 状态2：只包含数字2和3（都得有）
		// 1. 原状态后面只能添3
		// 2. 状态0这里后面也只能添3,构成包含这两个数字的情况
		dp[i][2] = (dp[i - 1][2] + dp[i - 1][0]) % MOD;
		
		// 状态3：只包含数字2、0和1（都得有）
		// 1. 原状态，后面能填1或者2
		// 2. 状态1的前提下只能填1,构成包含这三个数字的情况
		dp[i][3] = (dp[i - 1][3] * 2 + dp[i - 1][1]) % MOD;
		
		// 状态4：只包含数字2、0和3（都得有）
		// 1. 原状态，后面只能添0或者3
		// 2. 状态1前提下后面只能添3,构成包含这三个数字的情况
		// 3. 状态2前提下后面只能添0,构成包含这三个数字的情况
		dp[i][4] = (dp[i - 1][4] * 2 + dp[i - 1][1] + dp[i - 1][2]) % MOD;
		
		// 状态5：包含所有数字（包含0、1、2和3）（都得有）
		// 1. 原状态下后面只能添1或者3
		// 2. 状态3前提下后面只能添3
		// 3. 状态4后面只能添1
		dp[i][5] = (dp[i - 1][5] * 2 + dp[i - 1][3] + dp[i - 1][4]) % MOD;
	}
	cout << dp[n][5] << endl;
	return 0;
}
